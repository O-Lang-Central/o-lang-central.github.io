<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>O-Lang Protocol Specification v1.1</title>
  <meta name="description" content="O-Lang is a semantic orchestration protocol for governing AI and automation workflows outside application code.">
  <style>
    :root {
      --primary: #1e40af;
      --primary-dark: #1d3691;
      --dark: #0f172a;
      --light: #f8fafc;
      --gray: #64748b;
      --border: #e2e8f0;
      --code-bg: #f1f5f9;
      --warning-bg: #fef3c7;
      --warning-border: #f59e0b;
      --success-bg: #dcfce7;
      --success-border: #22c55e;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: var(--dark);
      background: var(--light);
      padding: 0;
    }

    header {
      background: white;
      border-bottom: 1px solid var(--border);
      padding: 2rem;
      text-align: center;
    }

    .header-content {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 800;
      color: var(--primary);
      letter-spacing: -0.5px;
      margin-bottom: 1rem;
    }

    .spec-meta {
      background: var(--code-bg);
      padding: 1rem;
      border-radius: 6px;
      font-family: monospace;
      font-size: 0.9rem;
      margin: 1rem 0;
    }

    main {
      max-width: 800px;
      margin: 2rem auto;
      padding: 0 1.5rem;
    }

    .section {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
      margin-bottom: 2rem;
    }

    .section h2 {
      font-size: 1.75rem;
      margin-bottom: 1.5rem;
      color: var(--primary-dark);
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.5rem;
    }

    .section h3 {
      font-size: 1.25rem;
      margin: 1.5rem 0 1rem 0;
      color: var(--primary);
    }

    .section h4 {
      font-size: 1.1rem;
      margin: 1.25rem 0 0.75rem 0;
      color: var(--dark);
    }

    p {
      margin-bottom: 1rem;
    }

    ul, ol {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
    }

    li {
      margin-bottom: 0.5rem;
    }

    pre {
      background: var(--code-bg);
      padding: 1rem;
      border-radius: 6px;
      overflow-x: auto;
      margin: 1rem 0;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 0.9rem;
    }

    code {
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      background: var(--code-bg);
      padding: 0.125rem 0.25rem;
      border-radius: 4px;
      font-size: 0.9em;
    }

    .normative {
      border-left: 4px solid var(--primary);
      padding-left: 1rem;
      margin: 1rem 0;
      background: rgba(30, 64, 175, 0.05);
    }

    .warning {
      background: var(--warning-bg);
      border-left: 4px solid var(--warning-border);
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 6px 6px 0;
    }

    .success {
      background: var(--success-bg);
      border-left: 4px solid var(--success-border);
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 6px 6px 0;
    }

    .quote {
      font-style: italic;
      border-left: 3px solid var(--gray);
      padding-left: 1rem;
      margin: 1.5rem 0;
      color: var(--gray);
    }

    .integration-example {
      background: #f0f9ff;
      border: 1px solid #bae6fd;
      padding: 1rem;
      border-radius: 6px;
      margin: 1rem 0;
    }

    footer {
      text-align: center;
      padding: 2rem;
      color: var(--gray);
      font-size: 0.875rem;
      border-top: 1px solid var(--border);
      margin-top: 2rem;
    }

    @media (max-width: 600px) {
      h1 { font-size: 2rem; }
      .header-content, main { padding: 0 1rem; }
      .section { padding: 1.5rem; }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <h1>O-Lang Protocol Specification v1.1</h1>
      <div class="spec-meta">
        Protocol: O-Lang/1.1<br>
        Status: Stable<br>
        Audience: Runtime implementers, SDK authors, platform & systems engineers<br>
        License: Apache 2.0
      </div>
    </div>
  </header>

  <main>
    <div class="section">
      <h2>1. Purpose & Philosophy</h2>
      <p>O-Lang is a semantic orchestration protocol for governing AI and automation workflows outside application code.</p>
      <p>Unlike orchestration frameworks embedded in programming languages, O-Lang defines:</p>
      <ul>
        <li>a portable execution format</li>
        <li>a runtime-enforced policy boundary</li>
        <li>a resolver invocation contract</li>
        <li>semantic enforcement of workflow meaning</li>
      </ul>
      <p><strong>O-Lang does not execute business logic.</strong><br>
      It governs how logic is invoked, constrained, observed, and audited.</p>
    </div>

    <div class="section">
      <h2>2. Core Concepts</h2>
      
      <h3>2.1 Kernel (Normative)</h3>
      <p>The Kernel is a semantic runtime, not an executor.</p>
      <p>It is responsible for:</p>
      <ul>
        <li>parsing workflows</li>
        <li>validating resolver eligibility</li>
        <li>enforcing execution policy</li>
        <li>tracking symbol lifecycles</li>
        <li>detecting semantic violations</li>
        <li>producing auditable outputs</li>
      </ul>
      <div class="normative">
        <strong>A kernel MUST NOT:</strong>
        <ul>
          <li>embed domain logic</li>
          <li>infer missing values</li>
          <li>silently ignore failures</li>
          <li>bypass resolver restrictions</li>
        </ul>
      </div>

      <h3>2.2 Workflow</h3>
      <p>A Workflow is a semantic contract, not a script.</p>
      <p><strong>Characteristics:</strong></p>
      <ul>
        <li>deterministic step order</li>
        <li>immutable inputs</li>
        <li>symbol-tracked outputs</li>
        <li>stateless execution</li>
        <li>observable failure modes</li>
      </ul>

      <h3>2.3 Resolver</h3>
      <p>A Resolver is an external capability boundary.</p>
      <p><strong>Resolvers may be:</strong></p>
      <ul>
        <li>HTTP services</li>
        <li>local binaries</li>
        <li>containers</li>
        <li>edge services</li>
        <li>IoT hardware interfaces</li>
      </ul>
      <p><strong>Resolvers are never trusted.</strong><br>
      All resolver results are validated by the kernel, not assumed correct.</p>
    </div>

    <div class="section">
      <h2>3. Syntax Grammar and Keywords (Normative)</h2>
      
      <h3>3.1 General Syntax Rules</h3>
      <p>O-Lang uses a line-oriented, English-like syntax. Whitespace is not significant except within quoted strings. All keywords are case-insensitive but conventionally capitalized.</p>

      <h3>3.2 Top-Level Structure</h3>
      <pre>Workflow "&lt;name&gt;" [with &lt;param&gt;+]

[Allow resolvers:
- &lt;resolver-name&gt;]+

&lt;step-or-block&gt;+

Return &lt;symbol&gt;</pre>

      <h3>3.3 Step Declaration</h3>
      <pre>[Step &lt;n&gt;:] Ask "&lt;query&gt;" Save as &lt;symbol&gt;
[Step &lt;n&gt;:] &lt;function&gt;(&lt;args&gt;) Save as &lt;symbol&gt;</pre>
      <ul>
        <li><code>Step &lt;n&gt;:</code> is optional and for human readability only</li>
        <li><code>&lt;function&gt;</code> may be a built-in (e.g., <code>add</code>, <code>concat</code>) or resolver name</li>
        <li><code>&lt;symbol&gt;</code> must be a single alphanumeric identifier (normalized by kernel)</li>
      </ul>

      <h3>3.4 Parallel Execution Blocks</h3>
      <pre>Run in parallel [for &lt;duration&gt;]
  &lt;step&gt;+
End</pre>
      <ul>
        <li><code>&lt;duration&gt;</code>: integer followed by time unit (<code>ms</code>, <code>s</code>, <code>m</code>, <code>h</code>)</li>
        <li>If <code>for</code> clause is omitted, block runs until all steps complete</li>
        <li>All steps inside execute concurrently</li>
        <li>Context is snapshotted before block entry</li>
      </ul>

      <h3>3.5 Conditional Logic</h3>
      <pre>If &lt;condition&gt;:
  &lt;step-or-block&gt;+
[Else:
  &lt;step-or-block&gt;+]
EndIf</pre>
      <ul>
        <li><code>&lt;condition&gt;</code>: system-provided boolean symbols only (<code>timed_out</code>, <code>escalation_completed</code>)</li>
        <li>User-defined symbols <strong>cannot</strong> be used in conditions (to preserve deterministic observability)</li>
      </ul>

      <h3>3.6 Persistence</h3>
      <pre>Persist &lt;symbol&gt; to "&lt;filepath&gt;"</pre>
      <ul>
        <li>Fails if <code>&lt;symbol&gt;</code> is undefined (semantic enforcement)</li>
        <li><code>&lt;filepath&gt;</code> is relative to execution environment’s output directory</li>
      </ul>
    </div>

    <div class="section">
      <h2>4. Semantic Execution Model (Normative)</h2>
      
      <h3>4.1 Symbols</h3>
      <p>A symbol is any named value referenced in a workflow:</p>
      <ul>
        <li>inputs</li>
        <li>step outputs (<code>Save as</code>)</li>
        <li>emitted values</li>
        <li>persisted values</li>
      </ul>
      <p>Symbols are tracked explicitly by the kernel.</p>

      <h3>4.2 Symbol Lifecycle</h3>
      <pre>Declared / Referenced
↓
Produced by Resolver  
↓
Available in Context
↓
Consumed or Persisted
↓
Observed or Missing</pre>

      <h3>4.3 Semantic Enforcement Rules</h3>
      <div class="normative">
        <strong>The kernel MUST:</strong>
        <ul>
          <li>detect when a symbol is referenced but undefined</li>
          <li>prevent persistence of undefined symbols</li>
          <li>emit warnings for partial execution</li>
          <li>never fabricate missing values</li>
        </ul>
      </div>
      <p><strong>Undefined ≠ null ≠ empty.</strong></p>

      <h3>4.4 Partial Success</h3>
      <p>O-Lang allows partial workflow success.</p>
      <p><strong>Example:</strong></p>
      <ul>
        <li>Step A succeeds</li>
        <li>Step B fails to produce output</li>
        <li>Step C still executes</li>
      </ul>
      <div class="normative">
        <strong>The kernel MUST surface:</strong>
        <ul>
          <li>which symbols are missing</li>
          <li>where they were expected</li>
          <li>what side-effects were skipped</li>
        </ul>
      </div>
    </div>

    <div class="section">
      <h2>5. Parallel and Timed Execution Semantics (Normative)</h2>
      
      <h3>5.1 Parallel Block Lifecycle</h3>
      <ol>
        <li>Kernel snapshots current context</li>
        <li>Launches all steps in block concurrently</li>
        <li>Waits up to <code>&lt;duration&gt;</code> (if specified)</li>
        <li>Cancels any incomplete steps after timeout</li>
        <li>Merges <strong>only successfully resolved symbols</strong> into post-block context</li>
        <li>Sets <code>timed_out = true</code> if any step was cancelled</li>
      </ol>

      <h3>5.2 Symbol Merge Rules</h3>
      <ul>
        <li><strong>Resolved symbol</strong>: included in final context</li>
        <li><strong>Unresolved symbol</strong>: discarded (not set to <code>null</code> or <code>undefined</code>)</li>
        <li><strong>Partially failed block</strong>: still progresses to next workflow step</li>
        <li><strong>No implicit error propagation</strong>: failure is observable but not exceptional</li>
      </ul>

      <h3>5.3 Escalation Chains (Reserved)</h3>
      <p>Syntax is reserved for multi-level timeout escalation. Not part of v1.1 core, but kernels MUST ignore unknown block types gracefully.</p>
    </div>

    <div class="section">
      <h2>6. Resolver Contract and Multi-Language Support</h2>
      
      <h3>6.1 Resolver Invocation</h3>
      <p>Resolvers are invoked via function-call syntax:</p>
      <pre>medical-api("{symptoms}") Save as diagnosis</pre>
      <ul>
        <li>Kernel resolves function name against <code>Allow resolvers</code> list</li>
        <li>If not allowed, kernel skips step and logs policy violation</li>
      </ul>

      <h3>6.2 Input/Output Contract</h3>
      <ul>
        <li><strong>Input</strong>: JSON-serializable context subset (only referenced symbols)</li>
        <li><strong>Output</strong>: Single JSON value or error</li>
        <li><strong>No side effects</strong>: resolvers cannot write files, call external APIs outside their sandbox, or modify global state</li>
      </ul>

      <h3>6.3 Multi-Language Implementation</h3>
      <p>Resolvers may be implemented in <strong>any language</strong> that can:</p>
      <ul>
        <li>Read JSON input from stdin or HTTP request</li>
        <li>Write JSON output to stdout or HTTP response</li>
        <li>Exit with code 0 (success) or non-zero (failure)</li>
      </ul>
      <p><strong>Examples:</strong></p>
      <ul>
        <li><strong>Python</strong>: HTTP resolver with Flask/FastAPI</li>
        <li><strong>JavaScript</strong>: Node.js subprocess or HTTP endpoint</li>
        <li><strong>Rust</strong>: Native binary accepting JSON over stdin</li>
        <li><strong>Go</strong>: gRPC or REST service</li>
        <li><strong>Shell</strong>: Script that reads <code>$1</code> as JSON and outputs result</li>
      </ul>

      <h3>6.4 Kernel-Resolver Interface</h3>
      <p>Kernels MUST support <strong>at least one</strong> of:</p>
      <ul>
        <li><strong>HTTP</strong>: <code>POST /resolve</code> with JSON payload</li>
        <li><strong>Subprocess</strong>: spawn binary with JSON arg</li>
        <li><strong>In-process</strong>: language-native function call (for embedded use)</li>
      </ul>
      <p>The choice of interface is <strong>implementation-defined</strong> — the protocol only specifies <strong>what</strong> is called, not <strong>how</strong>.</p>
    </div>

    <div class="section">
      <h2>7. Runtime Observability</h2>
      <div class="warning">
        <strong>This warning:</strong><br>
        <code>Cannot persist undefined value from "medical_summary"</code>
      </div>
      <p><strong>Means:</strong></p>
      <ul>
        <li>The symbol existed in intent</li>
        <li>It did NOT exist in reality</li>
        <li>The kernel refused to lie</li>
      </ul>
      <p><strong>This is semantic truth enforcement.</strong></p>
      <p>In most frameworks:<br>
      this would silently write null, "", or crash later.</p>
      <p><strong>O-Lang makes meaning observable.</strong></p>
    </div>

    <div class="section">
      <h2>8. Security Model</h2>
      <p>O-Lang directly addresses the Confused Deputy Problem (Hardy, 1988).</p>
      <p><strong>Why orchestration-in-code fails:</strong></p>
      <ul>
        <li>execution authority == developer authority</li>
        <li>tools inherit permissions implicitly</li>
        <li>no runtime enforcement layer</li>
      </ul>
      <p><strong>O-Lang solution:</strong></p>
      <ul>
        <li>workflow intent ≠ execution authority</li>
        <li>resolvers explicitly allowed</li>
        <li>kernel mediates every invocation</li>
      </ul>
      <p><strong>Resolvers never gain power they weren't granted.</strong></p>
    </div>

    <div class="section">
      <h2>9. IoT & Edge Architecture</h2>
      <pre>[ Sensor / Actuator ]
↓
[ Edge Resolver ]
↓
[ O-Lang Kernel ]
↓
[ Policy / Audit / Control Plane ]</pre>
      <p><strong>Why O-Lang fits IoT better than code orchestration:</strong></p>
      <ul>
        <li>offline-safe</li>
        <li>deterministic replay</li>
        <li>hardware isolation</li>
        <li>auditable decisions</li>
        <li>no dynamic code execution</li>
      </ul>
      <p><strong>O-Lang governs when hardware is touched — not how.</strong></p>
    </div>

    <div class="section">
      <h2>10. LangChain Integration</h2>
      
      <h3>10.1 LangChain as a Resolver</h3>
      <p>LangChain is just another resolver.</p>
      <div class="integration-example">
        <code>Step 2: Ask langchain-agent "{query}" Save as answer</code>
      </div>

      <h3>10.2 Complementary Usage</h3>
      <p>LangChain builds the flow → O-Lang governs execution.</p>
      <div class="quote">
        <strong>Rule:</strong><br>
        LangChain may construct intent<br>
        O-Lang must enforce execution
      </div>
    </div>

    <div class="section">
      <h2>11. Implementation Guidance</h2>
      <p>O-Lang is defined by its protocol semantics, not by any specific implementation. Multiple kernel implementations are expected and encouraged.</p>

      <h3>11.1 Reference Implementation</h3>
      <p>A reference implementation is provided to:</p>
      <ul>
        <li>demonstrate protocol semantics</li>
        <li>serve as a conformance baseline</li>
        <li>enable rapid ecosystem adoption</li>
      </ul>
      <p>The reference implementation is not normative — the specification takes precedence in all cases.</p>

      <h3>11.2 Conformance Requirements</h3>
      <p>All compliant implementations MUST:</p>
      <ul>
        <li>pass the official conformance test suite</li>
        <li>adhere to normative sections of this specification</li>
        <li>produce equivalent execution traces for identical inputs</li>
      </ul>
      <p>Implementation language, performance characteristics, and internal architecture are not constrained by this specification.</p>

      <h3>11.3 Ecosystem Interoperability</h3>
      <p>Kernels in different languages MUST interoperate at the protocol level:</p>
      <ul>
        <li>identical workflows produce equivalent contexts</li>
        <li>resolver contracts are language-agnostic</li>
        <li>audit trails are structurally consistent</li>
      </ul>
      <p>This ensures portability across environments while preserving governance guarantees.</p>
    </div>

    <div class="section">
      <h2>12. System Classification</h2>
      <p>O-Lang is not a developer framework, scripting language, or orchestration engine. It is a <strong>semantic governance protocol</strong> designed for systems-level integration.</p>

      <h3>12.1 What O-Lang Is Not</h3>
      <ul>
        <li><strong>Not a DSL</strong> — O-Lang does not define domain logic or business rules.</li>
       <li><strong>Not an operational workflow engine</strong> — O-Lang operates above traditional workflow engines as a governance layer, providing semantic validation, policy enforcement, and auditability rather than managing execution infrastructure.</li>
        <li><strong>Not a LangChain alternative</strong> — It does not replace developer-facing AI composition tools.</li>
      </ul>

      <h3>12.2 What O-Lang Is</h3>
      <ul>
        <li><strong>A semantic execution layer</strong> — Enforces meaning, symbol validity, and intent fidelity across heterogeneous runtimes.</li>
        <li><strong>A governance boundary</strong> — Mediates all external capability invocations with policy, audit, and compliance enforcement.</li>
        <li><strong>An AI systems primitive</strong> — Provides the missing contract between application intent and infrastructure execution in regulated AI environments.</li>
      </ul>

      <p>This classification ensures correct integration patterns and prevents misuse in contexts where developer-level orchestration is sufficient.</p>
    </div>

    <div class="section">
      <h2>13. Final Principle</h2>
      <div class="warning">
        <strong>If orchestration logic can bypass the runtime,<br>
        then orchestration does not exist.</strong>
      </div>
    </div>
  </main>

  <footer>
    <p>
      © 2026 O-Lang Protocol. Open specification licensed under Apache 2.0.
      <br>
      <a href="https://github.com/O-Lang-Central/conformance" target="_blank">Conformance Test Suite</a>
    </p>
  </footer>
</body>
</html>